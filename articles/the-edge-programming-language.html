<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Edge Programming Language - the jtriley.eth book</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../contributions-highlights.html"><strong aria-hidden="true">2.</strong> Contributions</a></li><li class="chapter-item expanded "><a href="../articles.html"><strong aria-hidden="true">3.</strong> Articles</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../articles/type-theory.html"><strong aria-hidden="true">3.1.</strong> Type Theory</a></li><li class="chapter-item expanded "><a href="../articles/the-edge-programming-language.html" class="active"><strong aria-hidden="true">3.2.</strong> The Edge Programming Language</a></li><li class="chapter-item expanded "><a href="../articles/the-vyper-compiler.html"><strong aria-hidden="true">3.3.</strong> The Vyper Compiler</a></li><li class="chapter-item expanded "><a href="../articles/evm-language-design.html"><strong aria-hidden="true">3.4.</strong> EVM Language Design</a></li><li class="chapter-item expanded "><a href="../articles/the-ether-deck.html"><strong aria-hidden="true">3.5.</strong> The Ether Deck</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">the jtriley.eth book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-edge-programming-language"><a class="header" href="#the-edge-programming-language">The Edge Programming Language</a></h1>
<p><em>jtriley.eth; 06 November, 2023</em></p>
<hr />
<p>Recently, I wrote an article on the state of the art in Ethereum Virtual Machine language design. It
spoke about all of the high and low level languages in use today and their benefits. This is a
follow up to the previous article.</p>
<p>It is only fitting that, as a follow up, I am calling for the abandonment of the state of the art in
pursuit of a fundamentally different approach; one that enables maximal developer control, defines
clear abstractions, and one that promotes emergent abstractions over imposed abstractions.</p>
<h2 id="motivations"><a class="header" href="#motivations">Motivations</a></h2>
<blockquote>
<p>“If I had asked people what they wanted, they would have said faster horses”</p>
<p>— Henry Ford, Rust advocates</p>
</blockquote>
<p>At the time of writing, Solidity dominates the smart contract language design space. Client
interfaces only implement Solidity’s Application Binary Interface (ABI), New Ethereum Improvement
Proposals (EIPs) implicitly use Solidity’s ABI, debuggers operate on Solidity source maps, and even
other smart contract languages start at Solidity’s base layer of abstraction and attempt to deviate
from the same bedrock with minor syntax differences and backend improvements.</p>
<p>Vyper has an excellent intermediate representation (IR), Fe has a novel model for bringing context
and system functionality into local scopes, Solidity is beginning to improve on modular and
functional code independent of contract objects. However, each language starts from the same
principles. Contracts are objects, code is reused primarily via inheritance if at all, and the
syntax is designed to look general purpose except where the EVM prohibits reasonable abstraction.</p>
<h3 id="adoption-games"><a class="header" href="#adoption-games">Adoption Games</a></h3>
<p>Adoption of smart contract languages is zero-sum when nothing novel is created from divergent
patterns. Engineers and companies are expected to use their own resources to learn a new language,
but the opportunity is only sufficient when the new language does what the old may not. Gas
efficiency and compiler performance are huge improvements to developer and user experiences, but are
not sufficient for adoption.</p>
<p>Zero-sum adoption games invariably devolve into code snippet dunking, cherry picked gas benchmarks,
and culture wars.</p>
<p>Adoption becomes positive-sum when and only when a new language enables constructs and functionality
not possible in the status quo. Resource investments are justified as teams reach the limits of what
Solidity can do (see: Seaport).</p>
<h3 id="solidity-20"><a class="header" href="#solidity-20">“Solidity 2.0”</a></h3>
<p>The meta for zero-sum adoption is a so-called “Solidity 2.0”, a language that looks and behaves like
Solidity, but with abstract data types and improved gas efficiency. This means generics, possibly
even trait or typeclass constraints, a better front end to generate better middle end code, and an
intermediate representation that does not take multiple IRL minutes to optimize.</p>
<p>This is not a terrible idea, but it still misses the mark and still falls into the same adoption
game trap as every other underfunded compiler in the space.</p>
<h3 id="status-quo-disruption"><a class="header" href="#status-quo-disruption">Status Quo Disruption</a></h3>
<p>The status quo exists for a reason, it is the meta. The contract-as-an-object model has served the
EVM space well for subtyping interfaces, abstracting data serialization, and creating high level
concepts on top of which we can build composable protocols.</p>
<p>However, we are reaching the limits of this abstraction stack. Assets cannot be efficiently
transferred without assembly, memory is allocated as if a garbage collector or memory management
runtime exists when it does not, inheritance tree complexity cascades as poor storage pointer
support prefers abstract contracts over custom data types and functions, and the type system suffers
from an identity crisis teetering between disallowing implicit type casts and allowing function
pointer poisoning.</p>
<h2 id="edge"><a class="header" href="#edge">Edge</a></h2>
<p>The solution to status quo ossification, solidity lookalikes, and zero-sum adoption games is Edge.
Edge begins from first principles and uses a relatively simple type system to construct novel
abstraction stacks starting as low as type checked opcodes and going as high as generic contract
objects.</p>
<p>Did you know, in a 2021 report on smart contracts (PDF) by Trail of Bits, it was found that around
90% of all EVM smart contracts are at least 56% similar, with 7% being completely identical? This is
not a signal of lack of innovation, rather it is a signal that code reuse demands the most
attention.</p>
<p>Clear semantics for namespaces and modules makes code reusable, parametric polymorphism (generics)
and subtyping (traits) make reusable code worth writing, and annotations for all EVM data locations
minimizes semantics imposed by the compiler.</p>
<p>Minimizing compiler semantic imposition improves granularity of developer control without relying on
backdoors such as inline assembly. Inline assembly should always be enabled but outside of the
standard library, its use should be considered a failure of the compiler. Practical inline assembly
is used for a single reason, the developer has more context than can be provided to the compiler.
This may be in the form of more efficient memory usage, arbitrary storage writes, bespoke
serialization and deserialization, and unconventional storage methods.</p>
<h2 id="from-first-principles"><a class="header" href="#from-first-principles">From First Principles</a></h2>
<p>Languages like Huff and ETK are special, they remove the guard rails and compiler-imposed
abstractions, they leave only the EVM and aliases over it. In the EVM there are no data types, no
functions, no encoding schemes, there is the word and the instruction.</p>
<h3 id="primitive-data-types"><a class="header" href="#primitive-data-types">Primitive Data Types</a></h3>
<p>The word and the instruction are maximally flexible, the word may be a jump target, a condition, an
external address, a data pointer, or just an arithmetic operand. The instruction does not care about
the structure of the data. The conditional jump instruction will jump if the condition is a non-zero
word. The call instruction does not care the call target is greater than 20 bytes. We could create a
data type called <code>word</code> to have this in the language.</p>
<pre><code class="language-rs">let myVariable: word = 0;
</code></pre>
<p>While this is maximally flexible, it is error prone, it performs no checks. From this, what data
types are useful to derive?</p>
<p>First, there are 7 distinct data locations that may be loaded to the stack or copied to memory:</p>
<ul>
<li>Storage: persistent disk storage (load, store)</li>
<li>Transient Storage: temporary memory storage (load, store)</li>
<li>Memory: linear read/write data buffer (load, store)</li>
<li>Calldata: linear read-only data buffer (load, copy)</li>
<li>Returndata: linear read-only data buffer (load, copy)</li>
<li>Code: linear read-only data buffer (copy)</li>
<li>External Code: linear read-only data buffer (copy)</li>
</ul>
<p>Since each has its own set of instructions, it would make sense for a language to construct data
pointer types for each.</p>
<pre><code class="language-rs">let myStoragePtr: &amp;s ptr = 0;
let myTransientPtr: &amp;t ptr = 0;
let myMemoryPtr: &amp;m ptr = 0;
let myCalldataPtr: &amp;cd ptr = 0;
let myReturndataPtr: &amp;r ptr = 0;
let myCodePtr: &amp;co ptr = 0;
let myExtCodePtr: &amp;ec ptr = 0;
</code></pre>
<blockquote>
<p>It is worth noting that pointers may point to arbitrary data types.</p>
<p>Solidity enables pointers only to complex data types.</p>
</blockquote>
<p>Additionally, constraints on integer sizes and signage are sensible, so we create <code>intN</code> and <code>uintN</code>
which are signed and unsigned integers. Casting to a larger integer size is a no-op, but casting
downward may require a check such that the new integer size has not overflowed.</p>
<pre><code class="language-rs">let myInteger: u256 = 0;
let mySmolInteger: u1 = 0;
</code></pre>
<p>Of course, not all numbers are created equal, a number of zero or one may be a boolean and a 20 byte
number may be an address.</p>
<pre><code class="language-rs">let myBool: bool = true;
let myAddr: addr = 0x00..00;
</code></pre>
<p>This alone is enough to construct typed instructions where types must be explicitly declared or cast
into the correct type for function execution.</p>
<pre><code class="language-rs">fn call(
    gas: u256,
    target: addr,
    value: u256,
    argPtr: &amp;m ptr,
    argLen: u256,
    retPtr: &amp;m ptr,
    retLen: u256,
) -&gt; bool;
</code></pre>
<p>Our call instruction can now be checked at compile time that the target is an address, the argument
and returndata pointers are memory pointers, and that the call returns a value of zero or one.</p>
<h3 id="complex-data-types"><a class="header" href="#complex-data-types">Complex Data Types</a></h3>
<p>Primitive data types are useful, but structured data types are also important more complex
interactions and computations.</p>
<p>The product type, aka structs and tuples, is important for grouping a number of different items with
different data types together.</p>
<pre><code class="language-rs">type MyStruct = { a: u8, b: u256 };

type MyPackedStruct = packed { a: u8, b: u8 };

type MyTuple = (u8, u256);
</code></pre>
<p>The sum type, aka enum or union, is important for representing one of a number of different states,
where each state may have different items and data types.</p>
<pre><code class="language-rs">type MyEnum = First | Second;

type MyUnion =
    | Rgb({ r: u8, g: u8, b: u8 })
    | Hex(u24);
</code></pre>
<p>Functions, while simply a code pointer to jump to and from with a sequence of instructions at the
jump target, are also, fundamentally, a data type. A function’s type, also known as its signature,
is a transition from input arguments to output arguments.</p>
<pre><code class="language-rs">type MyFunction = (u8, u8) -&gt; (bool, u16);
</code></pre>
<h3 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h3>
<p>Reading procedures start to finish unconditionally is not very useful, and while code pointers can
be used for jumping, we can add syntax sugar over this to make it more ergonomic.</p>
<h4 id="loops"><a class="header" href="#loops">Loops</a></h4>
<p>The simple loop block with optional <code>continue</code> and <code>break</code> keywords is a simple but powerful
abstraction.</p>
<pre><code class="language-rs">loop {
    break;
    continue;
}
</code></pre>
<p>More familiar loops can map directly to the underlying loop in a desugaring step.</p>
<pre><code class="language-rs">// while loop
while (condition) { .. }

loop {
    if (!condition) break;
    ..
}

// for loop
for (let i = 0; i &lt; list.len(); i++) { .. }

let i = 0;
loop {
    if (i &gt;= list.length()) break;
    ..
    i++;
}
</code></pre>
<h4 id="branching"><a class="header" href="#branching">Branching</a></h4>
<p>Branching based on boolean expressions and pattern matching is useful both for all the obvious
reasons and for program correctness. Exhaustive pattern matching helps program correctness when
pattern matching union data types.</p>
<pre><code class="language-rs">if (myBool) { } else { }

if (myOption matches Option::Some(n)) { n; } else { }

match myOption {
    Some(n) =&gt; { n; },
    None =&gt; { },
}
</code></pre>
<h3 id="functions"><a class="header" href="#functions">Functions</a></h3>
<p>Grouping instructions together into a code block with input and output values is good for
modularity, code reuse, and in some cases, reducing code size. We define functions as follows.</p>
<pre><code class="language-rs">fn myOtherAddFn(a: u256, b: u256) -&gt; u256 {
    return a + b;
}
</code></pre>
<h3 id="inline-assembly"><a class="header" href="#inline-assembly">Inline Assembly</a></h3>
<p>Inline assembly should ideally be limited to the standard library, however its use is a critical
component in allowing developers to break all abstractions and operate on opcodes directly.</p>
<pre><code class="language-rs">fn double(a: u8) -&gt; u8 {
    asm (a) -&gt; (a) {
        push1 0x02
        mul
    }
    return a;
}
</code></pre>
<h3 id="parametric-polymorphism"><a class="header" href="#parametric-polymorphism">Parametric Polymorphism</a></h3>
<p>Writing libraries in Solidity is challenging because to make the library generic every single type
must have its own function. That is to say, libraries use monomorphic data types in their
construction.</p>
<p>Library engineers are vital users of any language. Parametric polymorphism is a core component of a
great library system. Polymorphism refers to the ability to use different data types for the same
purpose, and parametric refers to a set of type parameters to other data types.</p>
<pre><code class="language-rs">type MyGenericEnum&lt;T&gt; =
    | Some(T)
    | None;

type MyGenericFunction&lt;T&gt; = (T, T) -&gt; T;
</code></pre>
<h3 id="subtyping"><a class="header" href="#subtyping">Subtyping</a></h3>
<p>Subtyping, the constraining of otherwise generic data types to have certain constants, functions,
and types associated with it, is also incredibly useful in constructing correctness focused systems
and clean abstractions.</p>
<pre><code class="language-rs">trait MyTrait {
    type MyType;

    const MY_CONST: MyType;

    fn toMyType(self: Self) -&gt; MyType;
}
</code></pre>
<h3 id="modules"><a class="header" href="#modules">Modules</a></h3>
<p>Modules, or libraries, is the other core component necessary to create quality, reusable code. This
is relatively simple, conceptually.</p>
<pre><code class="language-rs">pub mod MyModule {
    pub mod MyNestedModule {
        pub type MyType = u8;
   }
}

use MyModule::MyNestedModule::MyType;

type MyOtherType = MyType;
</code></pre>
<h3 id="contracts"><a class="header" href="#contracts">Contracts</a></h3>
<p>A contract object, in Solidity, is a collection of external functions that operate on its local
state. Interfaces and abstract contracts may behave like subtypes, constraining minimum function
implementations for the contract.</p>
<p>However, all contracts in the EVM are first and foremost single entry point executables. In this way
it is similar to Rust and C programs, where the <code>main</code> function is the entry point of the program.</p>
<h4 id="abi"><a class="header" href="#abi">ABI</a></h4>
<p>The ABI is a syntax sugar construct that enables both contract interface subtyping and calldata
pattern matching.</p>
<pre><code class="language-rs">abi MyABI {
    fn myFn(a: u8) -&gt; u8;
}

fn main() {
    match sig&lt;MyABI&gt;() {
        MyABI::myFn(a) =&gt; { return a; },
        _ =&gt; revert(),
    }
}
</code></pre>
<h4 id="contract-abi"><a class="header" href="#contract-abi">Contract ABI</a></h4>
<p>Contracts behave similarly to structs where ABI’s can constrain the interface and external functions
behave similarly to other high level languages like Solidity.</p>
<pre><code class="language-rs">contract MyContract {
    let myNumber: u8 = 0;
}

impl MyContract: MyABI {
    fn myFn(a: u8) -&gt; u8 {
        return a + self.myNumber;
    }
}
</code></pre>
<blockquote>
<p>Note that the <code>self</code> syntax is experimental and is subject to change.</p>
</blockquote>
<h3 id="comptime"><a class="header" href="#comptime">Comptime</a></h3>
<p>Comptime, or compile time, is a keyword enabling zero-cost abstractions through compile time code
execution.</p>
<p>Comptime branches perform conditional compilation based on constant values.</p>
<pre><code class="language-rs">comptime if CONFIG.CHAINID == 1 {
    tstore(slot, 1);
} else {
    sstore(slot, 1);
}
</code></pre>
<p>Comptime functions are evaluated and resolved at compile time. If the function may not be resolved,
a compiler error is thrown.</p>
<pre><code class="language-rs">comptime fn eip1967slot(slotName: &amp;m String) -&gt; u256 {
    return keccak256(slotName) - 1;
}

sstore(
    eip1967slot(&quot;eip1967.proxy.implementation&quot;.toString()),
    caller(),
);
</code></pre>
<h2 id="to-a-new-abstraction-stack"><a class="header" href="#to-a-new-abstraction-stack">To A New Abstraction Stack</a></h2>
<p>These fundamental building blocks enable both the definition of other languages’ constructs within
Edge and more. Constructs could be type checked SSTORE2 implementations, in memory hash maps,
Solidity ABI encoders, compressed ABI encoders, elliptic curve data types and methods, and even
nested virtual machines with no stack overhead.</p>
<p>The granularity of Huff with the type system and compile time code execution of a high level
language offers an unparalleled developer experience and enables functionality not possible in any
smart contract language. When developers want to break abstraction and create novel patterns, they
can do so without breaking out of the language with assembly blocks, they can simply change imports
and use lower level APIs developed over the EVM.</p>
<p>Solidity remains a great introductory language for developers to create and deploy an NFT in a dozen
or so lines of code. This is not the target audience of Edge. Edge is for experienced engineers and
teams that need more than what Solidity can offer. Edge is for choosing granularity of abstraction
without sacrificing important correctness checks within the language’s type system.</p>
<p>To a new abstraction stack. Good hacking 🤘</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../articles/type-theory.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../articles/the-vyper-compiler.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../articles/type-theory.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../articles/the-vyper-compiler.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../src/static/solidity.min.js"></script>


    </div>
    </body>
</html>
